use std::ops::{Deref, DerefMut};

use pyo3::exceptions::PyException;
use pyo3::prelude::*;
use pythonize::PythonizeTypes;

use crate::types;

/// Wraps rust structure with python class.
///
/// Implements:
/// - conversions
/// - `Deref`
/// - `__str__` method
#[macro_export]
macro_rules! wrap_class {
    (
        $(
            $ty:ident {
                $field:ident : $outer_ty:ty
            } : $( $derive:ident $(+)? )*
        ),*
        $(,)?
    ) => {$(
        /// Autogenerated python class wrapper inside of rust
        #[pyclass]
        #[derive($($derive,)*)]
        pub struct $ty {
            $field: $outer_ty,
        }

        impl Deref for $ty {
            type Target = $outer_ty;
            fn deref(&self) -> &Self::Target {
                &self.$field
            }
        }

        impl DerefMut for $ty {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.$field
            }
        }

        impl From<$outer_ty> for $ty {
            fn from(outer: $outer_ty) -> Self {
                Self {
                    $field: outer,
                }
            }
        }

        impl From<$ty> for $outer_ty {
            fn from(from: $ty) -> Self {
                from.$field
            }
        }

        #[pyproto]
        impl PyObjectProtocol for $ty {
            fn __str__(&self) -> String {
                format!("{:#?}", self)
            }
        }
    )*
        fn register_wrapped_classes(m: &PyModule) -> PyResult<()> {
            $(m.add_class::<$ty>()?;)*
            Ok(())
        }
    };
}

/// Into py error converter
pub fn to_py_err(err: impl Into<color_eyre::eyre::Error>) -> PyErr {
    fn to_string(mut err: &dyn std::error::Error) -> String {
        let mut s = String::new();
        let mut idx = 0;
        loop {
            s += &format!("    {}: {}\n", idx, &err.to_string());
            idx += 1;
            match err.source() {
                Some(e) => err = e,
                None => return s,
            }
        }
    }

    let err = err.into();
    let s = format!("Error: {}\n", err);

    PyException::new_err(s + &to_string(err.root_cause()))
}

/// Type for easy and type-safe translation between python and rust
#[derive(Debug, Clone, Copy, Eq, PartialEq)]
pub struct ToPy<T>(pub T);

impl<T> Deref for ToPy<T> {
    type Target = T;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl<T> DerefMut for ToPy<T> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl<T> ToPy<T> {
    #[allow(clippy::missing_const_for_fn)]
    pub fn into_inner(self) -> T {
        self.0
    }
}

pub struct Pythonizer;
impl PythonizeTypes for Pythonizer {
    type Map = types::dict::Dict;
    type List = types::list::List;
}

impl<'source, T: serde::de::DeserializeOwned> FromPyObject<'source> for ToPy<T> {
    fn extract(obj: &'source PyAny) -> PyResult<Self> {
        let obj = if obj.hasattr("to_rust")? {
            obj.call_method0("to_rust")?
        } else {
            obj
        };

        pythonize::depythonize(obj).map_err(to_py_err).map(Self)
    }
}

impl<'source, T: serde::Serialize> IntoPy<PyObject> for ToPy<T> {
    fn into_py(self, py: Python) -> PyObject {
        #[allow(clippy::expect_used)]
        pythonize::pythonize_custom::<Pythonizer, _>(py, &self.into_inner())
            .expect("Lets hope pythonize won't complain :(")
    }
}
